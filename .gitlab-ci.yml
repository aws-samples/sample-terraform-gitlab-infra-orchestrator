# GitLab CI/CD Pipeline for Terraform Orchestration Framework - SECURE VERSION
# Branch-based promotion workflow: dev → staging → production

stages:
  - validate
  - setup
  - plan
  - deploy
  - destroy
  - promote

variables:
  TF_VERSION: "1.9.8"
  TF_ROOT: ${CI_PROJECT_DIR}
  AWS_DEFAULT_REGION: ${AWS_DEFAULT_REGION:-"us-east-1"}
  GIT_STRATEGY: clone
  # Remove default values for security - require explicit configuration
  WORKSPACE_KEY_PREFIX: ${WORKSPACE_KEY_PREFIX:-"environments"}

# Workflow rules - optimized to prevent double pipeline execution
workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "web"
    - if: $CI_PIPELINE_SOURCE == "push" && ($CI_COMMIT_BRANCH == "dev" || $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "production")
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      variables:
        SKIP_DEPLOYMENT: "true"

# Secure cache configuration
cache:
  key: "tf-${CI_PROJECT_ID}-${CI_COMMIT_REF_SLUG}-${CI_PIPELINE_ID}"
  paths:
    - .terraform/
    - .terraform.lock.hcl

# Validate Terraform configuration
validate:
  stage: validate
  image: hashicorp/terraform:${TF_VERSION}
  before_script:
    - apk add --no-cache git
    - terraform --version
    - echo "Setting up secure Git authentication..."
    # Secure Git authentication without exposing token in URL
    - git config --global credential.helper store
    - echo "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}" > ~/.git-credentials
    - echo "Git authentication configured securely"
  script:
    - echo "Checking Terraform formatting..."
    - terraform fmt -recursive || echo "Some files were reformatted"
    - echo "Initializing Terraform for validation..."
    - terraform init -backend=false
    - echo "Validating Terraform configuration..."
    - terraform validate
    - echo "Configuration validation completed successfully"
  after_script:
    - rm -f ~/.git-credentials
  rules:
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_BRANCH == "staging"
    - if: $CI_COMMIT_BRANCH == "production"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Setup backend resources in shared services account
setup_backend:
  stage: setup
  image: hashicorp/terraform:${TF_VERSION}
  before_script:
    - apk add --no-cache jq aws-cli
    - aws --version
    # Secure credential validation
    - |
      if [ -z "$AWS_ACCESS_KEY_ID" ] || [ -z "$AWS_SECRET_ACCESS_KEY" ]; then
        echo "ERROR: AWS credentials not configured"
        echo "Please set AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, and AWS_SESSION_TOKEN as protected GitLab CI variables"
        exit 1
      fi
    # Validate required configuration variables
    - |
      if [ -z "$TERRAFORM_STATE_BUCKET" ] || [ -z "$TERRAFORM_LOCKS_TABLE" ]; then
        echo "ERROR: Required configuration variables not set"
        echo "Please set TERRAFORM_STATE_BUCKET and TERRAFORM_LOCKS_TABLE as GitLab CI variables"
        exit 1
      fi
  script:
    - |
      echo "Setting up shared backend resources"
      
      # Test AWS credentials without exposing details
      if aws sts get-caller-identity --query Account --output text >/dev/null 2>&1; then
        echo "AWS credentials validated successfully"
      else
        echo "ERROR: AWS credentials are invalid or expired"
        exit 1
      fi
      
      # Validate configuration file exists
      if [ ! -f "config/aws-accounts.json" ]; then
        echo "ERROR: config/aws-accounts.json not found"
        echo "Please copy config/aws-accounts.json.example and configure your account IDs"
        exit 1
      fi
      
      # Get shared services account ID with validation
      SHARED_SERVICES_ACCOUNT_ID=$(jq -r '.shared_services.account_id' config/aws-accounts.json)
      
      if [ "$SHARED_SERVICES_ACCOUNT_ID" = "null" ] || [ -z "$SHARED_SERVICES_ACCOUNT_ID" ]; then
        echo "ERROR: Shared services account ID not configured"
        exit 1
      fi
      
      # Validate account ID format (12 digits)
      if ! echo "$SHARED_SERVICES_ACCOUNT_ID" | grep -qE '^[0-9]{12}$'; then
        echo "ERROR: Invalid account ID format"
        exit 1
      fi
      
      echo "Configuration validated successfully"
      
      # Secure role assumption with external ID
      SHARED_SERVICES_ROLE_ARN="arn:aws:iam::${SHARED_SERVICES_ACCOUNT_ID}:role/OrganizationAccountAccessRole"
      EXTERNAL_ID="${CI_PROJECT_ID}-${CI_PIPELINE_ID}"
      
      echo "Assuming role for backend setup"
      if SHARED_CREDENTIALS=$(aws sts assume-role \
        --role-arn "$SHARED_SERVICES_ROLE_ARN" \
        --role-session-name "gitlab-backend-setup-${CI_PIPELINE_ID}" \
        --external-id "$EXTERNAL_ID" \
        --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
        --output text 2>/dev/null); then
        
        export AWS_ACCESS_KEY_ID=$(echo $SHARED_CREDENTIALS | cut -d' ' -f1)
        export AWS_SECRET_ACCESS_KEY=$(echo $SHARED_CREDENTIALS | cut -d' ' -f2)
        export AWS_SESSION_TOKEN=$(echo $SHARED_CREDENTIALS | cut -d' ' -f3)
        echo "Role assumption successful"
      else
        echo "ERROR: Failed to assume role in shared services account"
        echo "Please verify IAM role configuration and external ID setup"
        exit 1
      fi
      
      # Create S3 bucket for state storage
      echo "Setting up S3 bucket for Terraform state"
      if aws s3api head-bucket --bucket "$TERRAFORM_STATE_BUCKET" 2>/dev/null; then
        echo "S3 bucket already exists"
      else
        echo "Creating S3 bucket with security configurations"
        aws s3api create-bucket --bucket "$TERRAFORM_STATE_BUCKET" --region ${AWS_DEFAULT_REGION}
        aws s3api put-bucket-versioning --bucket "$TERRAFORM_STATE_BUCKET" --versioning-configuration Status=Enabled
        aws s3api put-bucket-encryption --bucket "$TERRAFORM_STATE_BUCKET" --server-side-encryption-configuration '{
          "Rules": [{
            "ApplyServerSideEncryptionByDefault": {
              "SSEAlgorithm": "AES256"
            }
          }]
        }'
        aws s3api put-public-access-block --bucket "$TERRAFORM_STATE_BUCKET" --public-access-block-configuration \
          "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
        echo "S3 bucket created with encryption and versioning"
      fi
      
      # Create DynamoDB table for state locking
      echo "Setting up DynamoDB table for state locking"
      if aws dynamodb describe-table --table-name "$TERRAFORM_LOCKS_TABLE" >/dev/null 2>&1; then
        echo "DynamoDB table already exists"
      else
        echo "Creating DynamoDB table with encryption"
        aws dynamodb create-table \
          --table-name "$TERRAFORM_LOCKS_TABLE" \
          --attribute-definitions AttributeName=LockID,AttributeType=S \
          --key-schema AttributeName=LockID,KeyType=HASH \
          --billing-mode PAY_PER_REQUEST \
          --sse-specification Enabled=true
        
        echo "Waiting for DynamoDB table to become active..."
        aws dynamodb wait table-exists --table-name "$TERRAFORM_LOCKS_TABLE"
        echo "DynamoDB table created successfully"
      fi
      
      # Create secure backend configuration
      mkdir -p shared
      cat > "shared/backend-common.hcl" << EOF
      bucket         = "${TERRAFORM_STATE_BUCKET}"
      key            = "terraform.tfstate"
      region         = "${AWS_DEFAULT_REGION}"
      dynamodb_table = "${TERRAFORM_LOCKS_TABLE}"
      encrypt        = true
      workspace_key_prefix = "${WORKSPACE_KEY_PREFIX}"
      skip_credentials_validation = false
      skip_metadata_api_check = false
      skip_region_validation = false
      use_path_style = false
      max_retries = 5
      EOF
      
      echo "Backend setup completed successfully"
  artifacts:
    paths:
      - shared/backend-common.hcl
    expire_in: 1 week
  rules:
    - if: $SKIP_DEPLOYMENT == "true"
      when: never
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_BRANCH == "staging"
    - if: $CI_COMMIT_BRANCH == "production"

# Secure plan template
.plan_template: &plan_template
  stage: plan
  image: hashicorp/terraform:${TF_VERSION}
  before_script:
    - apk add --no-cache jq aws-cli git
    # Secure Git authentication
    - git config --global credential.helper store
    - echo "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}" > ~/.git-credentials
  after_script:
    - rm -f ~/.git-credentials
  rules:
    - if: $DESTROY_ENVIRONMENT
      when: never
    - if: $SKIP_DEPLOYMENT == "true"
      when: never
    - when: on_success
  script:
    - |
      echo "Planning infrastructure for $ENVIRONMENT environment"
      
      SHARED_SERVICES_ACCOUNT_ID=$(jq -r '.shared_services.account_id' config/aws-accounts.json)
      SHARED_SERVICES_ROLE_ARN="arn:aws:iam::${SHARED_SERVICES_ACCOUNT_ID}:role/OrganizationAccountAccessRole"
      EXTERNAL_ID="${CI_PROJECT_ID}-${CI_PIPELINE_ID}"
      
      cat > "backend-with-assume-role.hcl" << EOF
      bucket         = "${TERRAFORM_STATE_BUCKET}"
      key            = "terraform.tfstate"
      region         = "${AWS_DEFAULT_REGION}"
      dynamodb_table = "${TERRAFORM_LOCKS_TABLE}"
      encrypt        = true
      workspace_key_prefix = "${WORKSPACE_KEY_PREFIX}"
      
      assume_role = {
        role_arn = "${SHARED_SERVICES_ROLE_ARN}"
        session_name = "gitlab-terraform-plan-${ENVIRONMENT}-${CI_PIPELINE_ID}"
        external_id = "${EXTERNAL_ID}"
      }
      EOF
      
      terraform init -reconfigure -backend-config=backend-with-assume-role.hcl
      
      if terraform workspace list | grep -q "^\\*\\?\\s*${ENVIRONMENT}\\s*$"; then
        terraform workspace select ${ENVIRONMENT} || true
      else
        terraform workspace new ${ENVIRONMENT} || terraform workspace select ${ENVIRONMENT}
      fi
      
      echo "Planning infrastructure changes"
      terraform plan -var-file=tfvars/${TFVARS_FILE} -out=tfplan
  artifacts:
    paths:
      - tfplan
      - backend-with-assume-role.hcl
    expire_in: 1 week

# Environment-specific plan jobs
plan:dev:
  <<: *plan_template
  variables:
    ENVIRONMENT: dev
    TFVARS_FILE: dev-terraform.tfvars
  rules:
    - if: $DESTROY_ENVIRONMENT
      when: never
    - if: $CI_COMMIT_BRANCH == "dev"

plan:staging:
  <<: *plan_template
  variables:
    ENVIRONMENT: staging
    TFVARS_FILE: stg-terraform.tfvars
  rules:
    - if: $DESTROY_ENVIRONMENT
      when: never
    - if: $CI_COMMIT_BRANCH == "staging"

plan:production:
  <<: *plan_template
  variables:
    ENVIRONMENT: production
    TFVARS_FILE: prod-terraform.tfvars
  rules:
    - if: $DESTROY_ENVIRONMENT
      when: never
    - if: $CI_COMMIT_BRANCH == "production"

# Secure deploy template
.deploy_template: &deploy_template
  stage: deploy
  image: hashicorp/terraform:${TF_VERSION}
  before_script:
    - apk add --no-cache jq aws-cli git
    - git config --global credential.helper store
    - echo "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}" > ~/.git-credentials
  after_script:
    - rm -f ~/.git-credentials
  rules:
    - if: $DESTROY_ENVIRONMENT
      when: never
    - if: $SKIP_DEPLOYMENT == "true"
      when: never
    - when: on_success
  script:
    - |
      echo "Deploying infrastructure to $ENVIRONMENT environment"
      
      terraform init -reconfigure -backend-config=backend-with-assume-role.hcl
      terraform workspace select $ENVIRONMENT || terraform workspace new $ENVIRONMENT
      terraform apply -auto-approve tfplan
      
      echo "Infrastructure deployed successfully to ${ENVIRONMENT}"
      terraform output

# Environment-specific deploy jobs
deploy:dev:
  <<: *deploy_template
  variables:
    ENVIRONMENT: dev
  needs:
    - job: plan:dev
      artifacts: true
  environment:
    name: development
  rules:
    - if: $DESTROY_ENVIRONMENT
      when: never
    - if: $CI_COMMIT_BRANCH == "dev"

deploy:staging:
  <<: *deploy_template
  variables:
    ENVIRONMENT: staging
  needs:
    - job: plan:staging
      artifacts: true
  environment:
    name: staging
  rules:
    - if: $DESTROY_ENVIRONMENT
      when: never
    - if: $CI_COMMIT_BRANCH == "staging"
      when: manual

deploy:production:
  <<: *deploy_template
  variables:
    ENVIRONMENT: production
  needs:
    - job: plan:production
      artifacts: true
  environment:
    name: production
  rules:
    - if: $DESTROY_ENVIRONMENT
      when: never
    - if: $CI_COMMIT_BRANCH == "production"
      when: manual

# Secure destroy template
.destroy_template: &destroy_template
  stage: destroy
  image: hashicorp/terraform:${TF_VERSION}
  before_script:
    - apk add --no-cache jq aws-cli git
    - git config --global credential.helper store
    - echo "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}" > ~/.git-credentials
  after_script:
    - rm -f ~/.git-credentials
  script:
    - |
      echo "Destroying infrastructure in $ENVIRONMENT environment"
      echo "WARNING: This will permanently delete all resources"
      
      SHARED_SERVICES_ACCOUNT_ID=$(jq -r '.shared_services.account_id' config/aws-accounts.json)
      SHARED_SERVICES_ROLE_ARN="arn:aws:iam::${SHARED_SERVICES_ACCOUNT_ID}:role/OrganizationAccountAccessRole"
      EXTERNAL_ID="${CI_PROJECT_ID}-${CI_PIPELINE_ID}"
      
      cat > "backend-with-assume-role.hcl" << EOF
      bucket         = "${TERRAFORM_STATE_BUCKET}"
      key            = "terraform.tfstate"
      region         = "${AWS_DEFAULT_REGION}"
      dynamodb_table = "${TERRAFORM_LOCKS_TABLE}"
      encrypt        = true
      workspace_key_prefix = "${WORKSPACE_KEY_PREFIX}"
      
      assume_role = {
        role_arn = "${SHARED_SERVICES_ROLE_ARN}"
        session_name = "gitlab-terraform-destroy-${ENVIRONMENT}-${CI_PIPELINE_ID}"
        external_id = "${EXTERNAL_ID}"
      }
      EOF
      
      terraform init -reconfigure -backend-config=backend-with-assume-role.hcl
      terraform workspace select $ENVIRONMENT || terraform workspace new $ENVIRONMENT
      
      echo "Destroying all infrastructure resources"
      terraform destroy -auto-approve -var-file=tfvars/${TFVARS_FILE}
      echo "Infrastructure destroyed successfully"

# Secure promotion job
create_promotion_mr:
  stage: promote
  image: alpine/git:latest
  before_script:
    - apk add --no-cache curl jq git
  script:
    - |
      echo "Creating automated promotion merge request"
      
      if [ "$CI_COMMIT_BRANCH" = "dev" ]; then
        TARGET_BRANCH="staging"
        PROMOTION_TYPE="Development → Staging"
      elif [ "$CI_COMMIT_BRANCH" = "staging" ]; then
        TARGET_BRANCH="production"
        PROMOTION_TYPE="Staging → Production"
      else
        echo "No promotion needed for branch $CI_COMMIT_BRANCH"
        exit 0
      fi
      
      echo "Creating promotion MR: $CI_COMMIT_BRANCH → $TARGET_BRANCH"
      
      MR_DESCRIPTION="## Infrastructure Promotion: $PROMOTION_TYPE

      This MR promotes infrastructure changes from **$CI_COMMIT_BRANCH** to **$TARGET_BRANCH**.

      ### Deployment Status
      - **Source**: \`$CI_COMMIT_BRANCH\` ✅ Deployed successfully
      - **Target**: \`$TARGET_BRANCH\` ⏳ Pending deployment
      - **Pipeline**: [$CI_PIPELINE_URL]($CI_PIPELINE_URL)

      ### Next Steps
      1. **Review** all infrastructure changes
      2. **Approve and merge** to trigger $TARGET_BRANCH deployment
      3. **Manual approval** required for $TARGET_BRANCH deployment

      ---
      *Automated promotion created after successful $CI_COMMIT_BRANCH deployment*"

      # Secure API token validation
      if [ -z "$GITLAB_API_TOKEN" ]; then
        echo "WARNING: GITLAB_API_TOKEN not set, skipping MR creation"
        exit 0
      fi
      
      # Check if MR already exists
      EXISTING_MR=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_API_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?source_branch=$CI_COMMIT_BRANCH&target_branch=$TARGET_BRANCH&state=opened" | \
        jq -r 'if type == "array" and length > 0 then .[0].iid else empty end' 2>/dev/null || echo "")
      
      if [ -n "$EXISTING_MR" ] && [ "$EXISTING_MR" != "null" ]; then
        echo "MR already exists: !$EXISTING_MR"
      else
        echo "Creating new MR"
        
        JSON_PAYLOAD=$(jq -n \
          --arg source "$CI_COMMIT_BRANCH" \
          --arg target "$TARGET_BRANCH" \
          --arg title "Promote Infrastructure: $PROMOTION_TYPE" \
          --arg desc "$MR_DESCRIPTION" \
          '{
            "source_branch": $source,
            "target_branch": $target,
            "title": $title,
            "description": $desc
          }')
        
        # Secure API call with error handling
        MR_RESPONSE=$(curl -s -w "\n%{http_code}" --request POST \
          --header "PRIVATE-TOKEN: $GITLAB_API_TOKEN" \
          --header "Content-Type: application/json" \
          --data "$JSON_PAYLOAD" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests" 2>/dev/null)
        
        HTTP_CODE=$(echo "$MR_RESPONSE" | tail -n1)
        
        if [ "$HTTP_CODE" = "201" ]; then
          echo "Promotion MR created successfully"
        else
          echo "Failed to create MR (HTTP $HTTP_CODE)"
          echo "Please create MR manually if needed"
        fi
      fi
  rules:
    - if: $DESTROY_ENVIRONMENT
      when: never
    - if: $CI_COMMIT_BRANCH == "dev"
      when: on_success
    - if: $CI_COMMIT_BRANCH == "staging"

# Environment-specific destroy jobs
destroy:dev:
  <<: *destroy_template
  variables:
    ENVIRONMENT: dev
    TFVARS_FILE: dev-terraform.tfvars
  rules:
    - if: $DESTROY_ENVIRONMENT == "dev"
      when: manual

destroy:staging:
  <<: *destroy_template
  variables:
    ENVIRONMENT: staging
    TFVARS_FILE: stg-terraform.tfvars
  rules:
    - if: $DESTROY_ENVIRONMENT == "staging"
      when: manual

destroy:production:
  <<: *destroy_template
  variables:
    ENVIRONMENT: production
    TFVARS_FILE: prod-terraform.tfvars
  rules:
    - if: $DESTROY_ENVIRONMENT == "production"
      when: manual